#include "bits/algorithm.hfa"
#include "bits/defs.hfa"

//-----------------------------------------------------------------------------
// is_lock
forall(L & | sized(L))
trait is_lock {
	// For acquiring a lock
	void lock( L & );

	// For releasing a lock
	void unlock( L & );
};


struct __mutex_stmt_lock_guard {
    void ** lockarr;
    __lock_size_t count;
};

static inline void ?{}( __mutex_stmt_lock_guard & this, void * lockarr [], __lock_size_t count  ) {
    this.lockarr = lockarr;
    this.count = count;

    // Sort locks based on address
    __libcfa_small_sort(this.lockarr, count);

    // acquire locks in order
    // for ( size_t i = 0; i < count; i++ ) {
    //     lock(*this.lockarr[i]);
    // }
}

static inline void ^?{}( __mutex_stmt_lock_guard & this ) with(this) {
    // for ( size_t i = count; i > 0; i-- ) {
    //     unlock(*lockarr[i - 1]);
    // }
}

forall(L & | is_lock(L)) {

    struct scoped_lock {
        L * internal_lock;
    };

    static inline void ?{}( scoped_lock(L) & this, L & internal_lock ) {
        this.internal_lock = &internal_lock;
        lock(internal_lock);
    }
    
    static inline void ^?{}( scoped_lock(L) & this ) with(this) {
        unlock(*internal_lock);
    }

    static inline void * __get_mutexstmt_lock_ptr( L & this ) {
        return &this;
    }

    static inline L __get_mutexstmt_lock_type( L & this );

    static inline L __get_mutexstmt_lock_type( L * this );
}
