//
// Cforall Version 1.0.0 Copyright (C) 2016 University of Waterloo
//
// The contents of this file are covered under the licence agreement in the
// file "LICENCE" distributed with Cforall.
//
// string -- variable-length, mutable run of text, with value semantics
//
// Author           : Michael L. Brooks
// Created On       : Fri Sep 03 11:00:00 2021
// Last Modified By : Peter A. Buhr
// Last Modified On : Mon Aug 28 18:32:59 2023
// Update Count     : 40
//

#pragma once

#include <fstream.hfa>


// in string_res.hfa
struct string_res;
struct charclass_res;

struct string {
    string_res * inner;
};

// Getters
size_t size(const string & s);

// RAII, assignment
void ?{}(string & this); // empty string
void ?{}(string & s, const char * initial); // copy from string literal (NULL-terminated)
void ?{}(string & s, const char * buffer, size_t bsize); // copy specific length from buffer

void ?{}(string & s, const string & s2);
void ?{}(string & s, string & s2);

void ?=?(string & s, const char * other); // copy assignment from literal
void ?=?(string & s, const string & other);
void ?=?(string & s, char other);
string & ?=?(string & s, string & other);  // surprising ret seems to help avoid calls to autogen
//string ?=?( string &, string ) = void;
void ^?{}(string & s);

// Alternate construction: request shared edits
struct string_WithSharedEdits {
    string * s;
};
string_WithSharedEdits ?`shareEdits( string & this );
void ?{}( string & this, string_WithSharedEdits src );

// IO Operator
ofstream & ?|?(ofstream & out, const string & s);
void ?|?(ofstream & out, const string & s);
ifstream & ?|?(ifstream & in, string & s);
void ?|?( ifstream & in, string & this );


struct _Istream_str {
	string & s;
	union {
		const char * scanset;
		char delimit[2];
	};
	int rwd;											// read width
	union {
		unsigned char all;
		struct {
			unsigned char ignore:1;						// do not change input argument
			unsigned char inex:1;						// include/exclude characters in scanset
			unsigned char delimit:1;					// delimit character
			unsigned char rwd:1;						// read width
		} flags;
	};
}; // _Istream_str

static inline {
	// read width does not include null terminator
	_Istream_str wdi( unsigned int rwd, string & s ) { return (_Istream_str)@{ s, {0p}, rwd, {.flags.rwd : true} }; }
	_Istream_str skip( const char scanset[] ) { return (_Istream_str)@{ *0p, {scanset}, -1, {.all : 0} }; }
	_Istream_str skip( unsigned int wd ) { return (_Istream_str)@{ *0p, {0p}, wd, {.all : 0} }; }
	_Istream_str getline( string & s, const char delimit = '\n' ) {
		return (_Istream_str)@{ s, {.delimit : { delimit, '\0' } }, -1, {.flags.delimit : true, .flags.inex : true} };
	}
	_Istream_str & getline( _Istream_str & fmt, const char delimit = '\n' ) {
		fmt.delimit[0] = delimit; fmt.delimit[1] = '\0'; fmt.flags.delimit = true; fmt.flags.inex = true; return fmt;
	}
	_Istream_str incl( const char scanset[], string & s ) { return (_Istream_str)@{ s, {scanset}, -1, {.flags.inex : false} }; }
	_Istream_str & incl( const char scanset[], _Istream_str & fmt ) { fmt.scanset = scanset; fmt.flags.inex = false; return fmt; }
	_Istream_str excl( const char scanset[], string & s ) { return (_Istream_str)@{ s, {scanset}, -1, {.flags.inex : true} }; }
	_Istream_str & excl( const char scanset[], _Istream_str & fmt ) { fmt.scanset = scanset; fmt.flags.inex = true; return fmt; }
	_Istream_str ignore( string & s ) { return (_Istream_str)@{ s, {0p}, -1, {.flags.ignore : true} }; }
	_Istream_str & ignore( _Istream_str & fmt ) { fmt.flags.ignore = true; return fmt; }
} // distribution
ifstream & ?|?( ifstream & is, _Istream_str f );
void ?|?( ifstream & is, _Istream_str t );
void getline( ifstream & in, string & this, const char delimit = '\n' );

// Concatenation
void ?+=?(string & s, char other); // append a character
void ?+=?(string & s, const string & s2); // append-concatenate to first string
void ?+=?(string & s, const char * other); // append-concatenate to first string
string ?+?(const string & s, char other); // add a character to a copy of the string
string ?+?(const string & s, const string & s2); // copy and concatenate both strings
string ?+?(const char * s1, const char * s2); // concatenate both strings
string ?+?(const string & s, const char * other); // copy and concatenate with NULL-terminated string

// Repetition
string ?*?(const string & s, size_t factor);
string ?*?(char c, size_t size);
string ?*?(const char *s, size_t size);

// Character access
char ?[?](const string & s, size_t index);
string ?[?](string & s, size_t index);  // mutable length-1 slice of original
//char codePointAt(const string & s, size_t index);  // to revisit under Unicode

// Comparisons
bool ?==?(const string & s, const string & other);
bool ?!=?(const string & s, const string & other);
bool ?==?(const string & s, const char * other);
bool ?!=?(const string & s, const char * other);

// Slicing
string ?()( string & this, size_t start, size_t end );  // TODO const?
string ?()( string & this, size_t start);

// String search
bool contains(const string & s, char ch); // single character

int find(const string & s, char search);
int find(const string & s, const string & search);
int find(const string & s, const char * search);
int find(const string & s, const char * search, size_t searchsize);

int findFrom(const string & s, size_t fromPos, char search);
int findFrom(const string & s, size_t fromPos, const string & search);
int findFrom(const string & s, size_t fromPos, const char * search);
int findFrom(const string & s, size_t fromPos, const char * search, size_t searchsize);

bool includes(const string & s, const string & search);
bool includes(const string & s, const char * search);
bool includes(const string & s, const char * search, size_t searchsize);

bool startsWith(const string & s, const string & prefix);
bool startsWith(const string & s, const char * prefix);
bool startsWith(const string & s, const char * prefix, size_t prefixsize);

bool endsWith(const string & s, const string & suffix);
bool endsWith(const string & s, const char * suffix);
bool endsWith(const string & s, const char * suffix, size_t suffixsize);

// Modifiers
void padStart(string & s, size_t n);
void padStart(string & s, size_t n, char padding);
void padEnd(string & s, size_t n);
void padEnd(string & s, size_t n, char padding);



struct charclass {
    charclass_res * inner;
};

void ?{}( charclass & ) = void;
void ?{}( charclass &, charclass) = void;
charclass ?=?( charclass &, charclass) = void;

void ?{}( charclass &, const string & chars);
void ?{}( charclass &, const char * chars );
void ?{}( charclass &, const char * chars, size_t charssize );
void ^?{}( charclass & );

int include(const string & s, const charclass & mask);

int exclude(const string & s, const charclass & mask);

/*
What to do with?
StrRet include(string & s, const charclass & mask);
StrRet exclude(string & s, const charclass & mask);
*/
