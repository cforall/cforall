#pragma once

#include "iostream.hfa"

forall( E ) trait Bounded {
    E lowerBound();
    E upperBound();
};

forall( E | Bounded( E ) ) trait Serial {
    unsigned fromInstance( E e );
    E fromInt( unsigned i );
    E succ( E e );
    E pred( E e );
};

forall( E | Serial( E ) ) trait CfaEnum {
    const char * label( E e );
    unsigned int posn( E e );
};

forall( E, V | CfaEnum( E ) ) trait TypedEnum {
    V value( E e );
};

// I/O

forall( istype & | istream( istype ), E | CfaEnum( E ) )
istype & ?|?( istype &, E & );

forall( ostype & | ostream( ostype ), E | CfaEnum( E ) ) {
	ostype & ?|?( ostype &, E );
	OSTYPE_VOID( E );
}

// forall( ostype & | ostream( ostype ), E | CfaEnum( E, quasi_void ) ) {
// 	ostype & ?|?( ostype &, E );
// 	OSTYPE_VOID( E );
// }

// Design two <- should go for this if we have change the cost model
// forall( E | Serial( E ) ) trait CfaEnum {
//     char * label( E e );
//     unsigned int posn( E e );
// };

// forall( E, V| CfaEnum( E)) trait TypedEnum {
//     V value( E e);
// };

static inline
forall( E | CfaEnum( E ) ) {
    int ?==?( E l, E r ) { return posn( l ) == posn( r ); }	// relational operators
    int ?!=?( E l, E r ) { return posn( l ) != posn( r ); }
    int ?<?( E l, E r ) { return posn( l ) < posn( r ); }
    int ?<=?( E l, E r ) { return posn( l ) <= posn( r ); }
    int ?>?( E l, E r ) { return posn( l ) > posn( r ); }
    int ?>=?( E l, E r ) { return posn( l ) >= posn( r ); }

    E ++?( E & l ) { 									// increment operators
        l = succ( l );
        return l;
    }
    
    E ?++( E & l ) {
        E ret = l;
        l = succ( l );
        return ret;
    }

    E --?( E & l ) {
        l = pred( l );
        return l;
    }

    E ?--( E & l ) {
        E ret = l;
        l = pred( l );
        return ret;
    }
}
